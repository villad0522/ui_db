[{"functionId":"test","functionNameJP":"テストコード","functionNameEN":"test","beforeCode":"","innerCode":"\n    //\n    // CSVファイルに書き込むデータ\n    const data = [\n        ['John Doe', 25, 'New York'],\n        ['Jane Smith', 30, 'San Francisco'],\n        ['Bob Johnson', 22, 'Los Angeles']\n    ];\n    const csvText = data.map(row => row.join(',')).join('\\n');\n    //\n    // CSVファイルのパス\n    const cachePath = await getPath(\"CACHE\");\n    const csvFilePath = path.join(cachePath, 'test.csv');\n    //\n    // CSVファイルを作成してデータを書き込む\n    await fs.promises.writeFile(csvFilePath, csvText, 'utf8');\n    //\n    // テーブルを作り直す\n    await runSqlWriteOnly(`DROP TABLE IF EXISTS t99999;`,{});\n    await runSqlWriteOnly(`\n        CREATE TABLE t99999 (\n            \"name\" TEXT,\n            \"age\" INTEGER,\n            \"city\" TEXT\n        );\n    `,{});\n    //\n    // CSVファイルからデータベースに読み込む\n    await createRecordsFromCsv( \"t99999\", csvFilePath, 3 );\n    //\n    // わざと再接続\n    await startUp(\"localhost:3000\", true);\n    //\n    // テーブルから読み出す\n    const matrix = await runSqlReadOnly(`SELECT * FROM t99999`,{});\n    if (matrix.length !== data.length) {\n        console.log(matrix);\n        throw `インポートしたはずの件数と合致しません`;\n    }\n    if (matrix[0][\"name\"] !== data[0][0]) {\n        console.log(matrix);\n        throw `インポートしたはずの内容と合致しません`;\n    }\n    //\n    // CSVファイルを削除\n    await fs.promises.rm(csvFilePath);\n    //\n    // テスト用のテーブルを削除\n    await runSqlWriteOnly(`\n        DROP TABLE IF EXISTS t99999;\n    `,{});\n","afterCode":"","parametersName":[],"parametersDataType":[],"returnValue":"void"},{"functionNameJP":"プログラム起動","functionNameEN":"startUp","parametersName":["localUrl","isDebug"],"parametersDataType":["string_nullable","boolean"],"returnValue":"void","functionId":"01HM2TE8CJ7CMTPVVNCZV4H3F6","beforeCode":"\n\n\nimport path from 'path';\nimport sqlite3 from 'sqlite3'\nimport csvParser from 'csv-parser';\nimport iconv from 'iconv-lite';\nimport { Database } from 'sqlite'\nimport fs from 'fs';\n\n// 使用したnpmパッケージ「sqlite」\n//  https://github.com/kriasoft/node-sqlite#readme\n\n//【グローバル変数】データベースとの接続情報\nlet db = null;\n\n//【グローバル変数】接続中？\nlet isConnect = false;\n\n//【グローバル変数】デバッグモード\nlet isDebug = false;\n\n//【グローバル変数】トランザクション処理中？\nlet isTransaction = false;\n\n","innerCode":"\n  if (isTransaction === true) {\n    await db.run(\"COMMIT TRANSACTION;\");\n  }\n  if (isConnect === true) {\n    await db.close();\n    isConnect = false;\n  }\n  //\n  await startUp( localUrl );   // 下層の関数を呼び出す\n  //\n  // フォルダのパス\n  const directoryPath = await getPath(\"SAVEDATA\");\n  //\n  // データベースファイルのパス\n  const mainFilePath = path.join(directoryPath, \"main.db\");\n  const practiceFilePath = path.join(directoryPath, \"practice.db\");\n  //\n  let filePath;\n  if (isDebug) {\n    // デバッグモードの場合\n    if (fs.existsSync(mainFilePath)) {\n      // メインデータを汚さないようにコピーする\n      await fs.promises.copyFile(mainFilePath, practiceFilePath);\n    }\n    // コピーしたデータを使用する\n    filePath = practiceFilePath;\n  }\n  else {\n    // 通常動作の場合、メインデータを直接操作する\n    filePath = mainFilePath;\n  }\n  //\n  db = new Database({\n    filename: filePath,\n    driver: sqlite3.Database\n  });\n  await db.open();\n  isConnect = true;\n  db.configure('busyTimeout', 3000);  // 3 seconds\n  await db.exec(\"PRAGMA foreign_keys = 1;\"); // 外部キー制約を有効にする\n  if (isTransaction === true) {\n    await db.run(\"BEGIN TRANSACTION;\");\n  }\n","afterCode":""},{"functionNameJP":"デバッグモード判定","functionNameEN":"getDebugMode","parametersName":[],"parametersDataType":[],"returnValue":"boolean","functionId":"01HM2TS4QQ71Q6ADAHK9QJBHRS","beforeCode":"\n\n","innerCode":"\n  return isDebug;\n","afterCode":""},{"functionNameJP":"トランザクション処理開始","functionNameEN":"startTransaction","parametersName":[],"parametersDataType":[],"returnValue":"void","functionId":"01HM2TW350TBX5QTGD3MBEWYK2","beforeCode":"\n\n","innerCode":"\n  if(isTransaction===false){\n    isTransaction = true;\n    await db.run(\"BEGIN TRANSACTION;\");\n  }\n","afterCode":""},{"functionNameJP":"トランザクション処理終了","functionNameEN":"endTransaction","parametersName":[],"parametersDataType":[],"returnValue":"void","functionId":"01HM2TWJ3R5HVY1DGJCGW67CYD","beforeCode":"\n\n","innerCode":"\n  if(isTransaction===true){\n    isTransaction = false;\n    await db.run(\"COMMIT TRANSACTION;\");\n  }\n","afterCode":""},{"functionNameJP":"SQLクエリ実行（読み取り専用）","functionNameEN":"runSqlReadOnly","parametersName":["sql","params"],"parametersDataType":["string",{"string":"any"}],"returnValue":[{"string":"any"}],"functionId":"01HM2V9F07NZY3B5YTVH71A381","beforeCode":"\n\n","innerCode":"\n  if (!params) {\n    // パラメータなし\n    try {\n      return await db.all(sql);\n    }\n    catch (err) {\n      throw `SQL文の実行中にエラーが発生しました。\\n\\n${err}\\n\\n${sql}`;\n    }\n  }\n  else {\n    // パラメータあり\n    try {\n      return await db.all(sql, params);\n    }\n    catch (err) {\n      throw `SQL文の実行中にエラーが発生しました。\\n\\n${err}\\n\\n${sql}\\n\\n${JSON.stringify(params, null, 2)}`;\n    }\n  }\n","afterCode":""},{"functionNameJP":"SQLクエリ実行（書き込み専用）","functionNameEN":"runSqlWriteOnly","parametersName":["sql","params"],"parametersDataType":["string",{"string":"any"}],"returnValue":"void","functionId":"01HM2VCWFXG7KVV4EMJRME4MM9","beforeCode":"\n\n","innerCode":"\n  if (Object.keys(params).length===0) {\n    // パラメータなし\n    try {\n      return await db.run(sql);\n    }\n    catch (err) {\n      throw `SQL文の実行中にエラーが発生しました。\\n\\n${err}\\n\\n${sql}`;\n    }\n  }\n  else {\n    // パラメータあり\n    try {\n      return await db.run(sql, params);\n    }\n    catch (err) {\n      throw `SQL文の実行中にエラーが発生しました。\\n\\n${err}\\n\\n${sql}\\n\\n${JSON.stringify(params, null, 2)}`;\n    }\n  }\n","afterCode":""},{"functionNameJP":"CSVファイルインポート","functionNameEN":"createRecordsFromCsv","parametersName":["tableId","filePath","columnSize"],"parametersDataType":["string","string","number"],"returnValue":"string","functionId":"01HM2VKCWJ5W6V3FFAGP4VTJZN","beforeCode":"\n\n\n//【グローバル変数】CSVファイルを読み込む進捗\nlet progressCSV = 0;\n\n","innerCode":"\n  // CSVファイルを読み込む\n  const fileStream = fs.createReadStream(filePath);\n  const headers = [];\n  for (let i = 0; i < columnSize; i++) {\n      headers.push(\":\" + String(i));\n  }\n  // 配列「headers」には :0, :1, :2... が格納されているはず\n  //\n  const parser = fileStream\n      .pipe(iconv.decodeStream('Shift_JIS'))\n      .pipe(csvParser({ headers: headers }));\n  //\n  // CSVファイルの行数を調べる\n  const fileContent = await fs.promises.readFile(filePath, 'utf8');\n  const csvSize = fileContent.split('\\n').length;\n  //\n  // CSVファイルからデータベースへ移行する\n  const stmt = await db.prepare(`INSERT INTO ${tableId} VALUES ( ${headers.join(\", \")} )`);\n  let errorCount = 0;\n  let allCount = 0;\n  await new Promise((resolve, reject) => {\n    parser.on('data', async (row) => {\n      try {\n        // データベースに挿入する処理\n        await stmt.run(row);\n      }\n      catch (err) {\n          errorCount++;\n          console.error(\"失敗\");\n      }\n      allCount++;\n      if (allCount % 10000 === 0) {\n        progressCSV = Math.floor(allCount / csvSize * 100);\n        console.log(`${progressCSV}%`);\n        //\n        // トランザクション処理で処理を高速化する。\n        //   開始と終了は、0200_transaction.jsに記述してあるので、\n        //   ここでは１万行ごとの再接続のみを行う。\n        await db.run(\"COMMIT TRANSACTION;\");    // 終了\n        await db.run(\"BEGIN TRANSACTION;\");     // 開始\n      }\n    }).on('end', () => {\n        resolve();\n    });\n  });\n  await stmt.finalize();\n  const successCount = allCount - errorCount;\n  return `CSVファイルの内容を、データベースに追記しました。${successCount}件の追記に成功して、${errorCount}件の追記に失敗しました。`;\n","afterCode":""},{"functionNameJP":"インポートの進捗状況を取得する関数","functionNameEN":"getCsvProgress","parametersName":[],"parametersDataType":[],"returnValue":"number","functionId":"01HM2VW7578HFQ3HKS086Y037K","beforeCode":"\n\n","innerCode":"\n  return progressCSV;\n","afterCode":""},{"functionNameJP":"バックエンドプログラム終了","functionNameEN":"close","parametersName":[],"parametersDataType":[],"returnValue":"void","functionId":"01HM2WJ7WYS82N34N3J3ZTH8E7","beforeCode":"\n\n","innerCode":"\n  if (isConnect === true) {\n    await db.close();\n    isConnect = false;\n  }\n","afterCode":"\n"}]