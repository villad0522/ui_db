[{"functionId":"test","functionNameJP":"テストコード","functionNameEN":"test","beforeCode":"","innerCode":"\n    await startUp(\"http://localhost:3000/\", true);\n    await getDebugMode();\n    await startTransaction();\n    await endTransaction();\n    await close();\n    //\n    //\n    await startUp(\"http://localhost:3000/\", true);\n    //\n    // CSVファイルに書き込むデータ\n    const data = [\n        ['John Doe', 25, 'New York'],\n        ['Jane Smith', 30, 'San Francisco'],\n        ['Bob Johnson', 22, 'Los Angeles']\n    ];\n    const csvText = data.map(row => row.join(',')).join('\\n');\n    //\n    // CSVファイルのパス\n    const cachePath = await getPath(\"CACHE\");\n    const csvFilePath = path.join(cachePath, 'test.csv');\n    //\n    // CSVファイルを作成してデータを書き込む\n    await fs.promises.writeFile(csvFilePath, csvText, 'utf8');\n    //\n    // CSVファイルからデータベースに読み込む\n    await createRecordsFromCsv(csvFilePath);\n    //\n    // テーブルから読み出す\n    const matrix = await runSqlReadOnly(`SELECT * FROM csv_data;`,{});\n    if (matrix.length !== data.length) {\n        console.log(matrix);\n        throw `インポートしたはずの件数と合致しません`;\n    }\n    if (matrix[0][\"c0\"] !== data[0][0]) {\n        console.log(matrix);\n        throw `インポートしたはずの内容と合致しません`;\n    }\n    //\n    // CSVファイルを削除\n    await fs.promises.rm(csvFilePath);\n    //\n    // テスト用のテーブルを削除\n    await runSqlWriteOnly(`\n        DROP TABLE IF EXISTS csv_data;\n    `,{});\n    //\n    // わざと再接続\n    await startUp(\"localhost:3000\", true);\n    //\n    await close();\n","afterCode":"","parametersName":[],"parametersDataType":[],"returnValue":"void"},{"functionNameJP":"CSVファイルインポート","functionNameEN":"createRecordsFromCsv","parametersName":["fileName","filePath"],"parametersDataType":["string","string"],"returnValue":"void","functionId":"01HM2VKCWJ5W6V3FFAGP4VTJZN","beforeCode":"\n\n\nimport iconv from 'iconv-lite';\nimport readline from 'readline';\nimport fs from 'fs';\n\n// 使用したnpmパッケージ「sqlite」\n//  https://github.com/kriasoft/node-sqlite#readme\n\n\n//【グローバル変数】CSVファイルを読み込む進捗\nlet successCount = 0;\nlet errorCount = 0;\nlet allCount = 0;\nlet csvSize = 0;\nlet progressMessage = \"何も処理をしていません\";\nlet parserStream;\nlet stmt;\n\n\n\n","innerCode":"\n  if( parserStream ){\n    throw `既に別の処理が動いています`;\n  }\n  if (!fs.existsSync(filePath)) {\n    throw 'ファイルが見つかりません。';\n  }\n  const db = await getDB();\n  if(!db){\n    throw \"データベースオブジェクト(db)がNULLです。\";\n  }\n  errorCount = 0;\n  allCount = 0;\n  successCount = 0;\n  //\n  //==============================================================================\n  // CSVファイルの行数と列数を調べる\n  progressMessage = `【処理中】CSVファイルの行数と列数を調べています。`;\n  let readline1 = readline.createInterface({\n    input: fs.createReadStream(filePath),\n    crlfDelay: Infinity   // 改行が見つかるまで待機\n  });\n  csvSize = 0;      // 行のサイズ\n  let columnSize = 0;   // 列のサイズ\n  let isFirstLine = true; \n  for await (const line of readline1) {\n    if(line.trim() === \"\") continue; // 空白をトリムしてから比較\n    if(isFirstLine){\n      columnSize = Object.keys(line.split(\",\")).length;\n      isFirstLine = false;\n    }\n    csvSize++;\n  }\n  if(csvSize===0){\n    throw \"CSVがゼロ行です。\";\n  }\n  if (columnSize === 0) {\n    throw `CSVファイルを読み込もうとしましたが、列が存在しません。`;\n  }\n  readline1.close();\n  readline1 = null;       // メモリを開放する\n  //\n  //==============================================================================\n  // テーブルを作り直す\n  progressMessage = `【処理中】トランザクション処理を開始しています。`;\n  await startTransaction();  // 開始\n  progressMessage = `【処理中】表を用意しています。`;\n  const fileName2 = fileName.substring(0, fileName.lastIndexOf(\".\"));\n  let tableName = fileName2;\n  let tableNumber = 2;\n  while( await getTableIdFromName(tableName) ){\n    // 既に同じ名前のテーブルが存在する場合\n    tableName = fileName2 + String(tableNumber);\n    tableNumber++;\n  }\n  const { tableId } = await createTable(tableName);\n  const columnIdList = [];\n  for (let i = 0; i < columnSize; i++) {\n    const { columnId } = await createColumn( tableId, i+\"列目\", \"TEXT\", null );\n    columnIdList.push( columnId );\n  }\n  progressMessage = `【処理中】トランザクション処理を終了しています。のちに再開する予定です。`;\n  await endTransaction();    // 終了\n  //\n  //\n  //==============================================================================\n  // データ移行の準備を行う\n  progressMessage = `【処理中】ファイルストリームを準備しています。`;\n  parserStream = fs.createReadStream(filePath)\n    .pipe(iconv.decodeStream('Shift_JIS'));\n  const sql = `\n    INSERT INTO ${tableId} (\n        sort_number,\n        created_at,\n        updated_at,\n        ${columnIdList.join(\", \")}\n      )\n      VALUES ( ?, ?, ?, ${new Array(columnSize).fill(\"?\").join(\", \")} );`;\n  let sortNumber = 128 + ( csvSize * 8 );\n  const createdAt = new Date().getTime();\n  const updatedAt = createdAt;\n  //\n  //==============================================================================\n  // 1000行をまとめてデータベースへ移行する\n  let isInterval = false;\n  let datas = [];\n  async function intervalFunc(){\n    progressMessage = `【処理中】トランザクション処理を開始しています。`;\n    await startTransaction();  // 開始\n    if(stmt){\n      progressMessage = `【処理中】データベースに送信した命令の完了を待っています。`;\n      await stmt.finalize();\n    }\n    progressMessage = `【処理中】SQLの命令文を準備しています。`;\n    stmt = await db.prepare(sql);\n    progressMessage = `【処理中】データベースに命令を送信しています。`;\n    const buf = datas;\n    datas = [];       // グローバル変数に代入\n    //\n    // データベースに挿入する処理\n    for( const cells of buf ){\n      await stmt.run([\n        sortNumber,\n        createdAt,\n        updatedAt,\n        ...cells,\n      ]);\n      sortNumber -= 8;\n      successCount++;\n    }\n    progressMessage = `【処理中】データベースに送信した${buf.length}件の命令の完了を待っています。`;\n    await stmt.finalize();\n    stmt = null;\n    progressMessage = `【処理中】トランザクション処理を確定させています。`;\n    await endTransaction();    // 終了\n    isInterval = false;\n    if(parserStream){\n      progressMessage = `【処理中】CSVファイルからの読み出しを再開しています。`;\n      parserStream.resume();\n      progressMessage = `【処理中】CSVファイルから読み出しています。`;\n    }\n    else{\n      // 処理が中断された場合\n      errorCount = 0;\n      allCount = 0;\n      successCount = 0;\n      csvSize = 0;\n      progressMessage = \"何も処理をしていません\";\n    }\n  }\n  //\n  //==============================================================================\n  // １行を読み込む\n  const threads = [];\n  function oneLine(lineText){\n    const matrix = parseCsv(lineText);\n    for(const cells of matrix){\n      try{\n        if( cells.length === columnSize ){\n          datas.push(cells);\n        }\n        else{\n          console.error(`\\n本来の列のサイズと異なります。\\n現状: ${cells.length}\\n本来: ${columnSize}`);\n          console.error(cells);\n          errorCount++;\n        }\n      }\n      catch(err){\n        console.error(`\\nCSVの解析に失敗しました。`);\n        console.error(line);\n        console.error(err);\n        errorCount++;\n      }\n      allCount++;\n      if (allCount % 1000 === 0) {\n        // 1000行に一度、実行する\n        if( isInterval === true ) continue;\n        if( datas.length===0 ) continue;\n        isInterval = true;\n        progressMessage = `【処理中】CSVファイルからの読み出しを一時停止しています。`;\n        parserStream.pause();\n        threads.push(intervalFunc());\n      }\n    }\n  }\n  //\n  //==============================================================================\n  // CSVファイルから読み出す\n  progressMessage = `【処理中】CSVファイルから読み出しています。`;\n  let rest = \"\";\n  await new Promise((resolve, reject) => {\n    parserStream.on('data', (text1) => {\n      if(!parserStream) {\n        console.error(\"処理が中断されました\");\n        return;\n      }\n      const results = splitLastNewline( rest + text1 );\n      rest = results[1];\n      oneLine( results[0] );\n    }).on('end', () => {\n        resolve();\n    });\n  });\n  if( rest.length > 0 ){\n    oneLine( rest );\n  }\n  //==============================================================================\n  await Promise.all(threads);\n  if( datas.length>0 ){\n    await intervalFunc();\n  }\n  progressMessage = `【最終処理中】ファイルストリームを破棄しています。`;\n  parserStream.destroy();\n  parserStream = null;\n  progressMessage = `完了しました。`;\n","afterCode":""},{"functionNameJP":"インポートの進捗状況を取得する関数","functionNameEN":"getCsvProgress","parametersName":[],"parametersDataType":[],"returnValue":{"progressMessage":"string","successCount":"number","errorCount":"number","csvSize":"number"},"functionId":"01HM2VW7578HFQ3HKS086Y037K","beforeCode":"\n\n\n\n// CSV行を配列へ変換する関数\n//  参考：https://zenn.dev/itte/articles/516228940932a5\nconst parseCsv = csv => csv.replace(/\\r/g, '').split('\\n').reduce(([data, isInQuotes], line) => {\n  const [datum, newIsInQuotes] = ((isInQuotes ? '\"' : '') + line).split(',').reduce(([datum, isInQuotes], text) => {\n    const match = isInQuotes || text.match(/^(\\\"?)((.*?)(\\\"*))$/)\n    if (isInQuotes) datum[datum.length - 1] += ',' + text.replace(/\\\"+/g, m => '\"'.repeat(m.length / 2))\n    else datum.push(match[1] ? match[2].replace(/\\\"+/g, m => '\"'.repeat(m.length / 2)) : match[2])\n    return [datum, isInQuotes ? !(text.match(/\\\"*$/)[0].length % 2) : match[1] && !(match[4].length % 2)]\n  }, [[]])\n  if (isInQuotes) data[data.length - 1].push(data[data.length - 1].pop() + '\\n' + datum[0], ...datum.slice(1))\n  else data.push(datum)\n  return [data, newIsInQuotes]\n}, [[]])[0]\n\n\n// \"最後の改行\" をもとに、文字列を２つに分割する関数\nfunction splitLastNewline(inputString) {\n  const lastNewlineIndex = inputString.lastIndexOf('\\n');\n  if (lastNewlineIndex !== -1) {\n    return [\n      inputString.substring(0, lastNewlineIndex),\n      inputString.substring(lastNewlineIndex + 1)\n    ];\n  } else {\n    // 改行が見つからない場合、元の文字列をそのまま返す\n    return [\"\", inputString];\n  }\n}\n\n","innerCode":"\n  return {\n    \"progressMessage\": progressMessage,\n    \"successCount\": successCount,\n    \"errorCount\": errorCount,\n    \"csvSize\": csvSize,\n  }\n","afterCode":""},{"functionNameJP":"インポートを中断する関数","functionNameEN":"destroyCSV","parametersName":[],"parametersDataType":[],"returnValue":"string","functionId":"01HN9C6Q664SGW914SWSDC9FF1","beforeCode":"\n\n\n","innerCode":"\n  setTimeout(()=>{\n    errorCount = 0;\n    allCount = 0;\n    successCount = 0;\n    csvSize = 0;\n    progressMessage = \"何も処理をしていません\";\n  },500);\n  if(parserStream){\n    // ストリームを中断・破棄\n    parserStream.pause();\n    parserStream.resume();\n    parserStream.destroy();\n    parserStream = null;\n    return \"CSVのアップロード処理を中断しました。\";\n  }\n  else{\n    return \"現在、何も実行されていません。\";\n  }\n","afterCode":""},{"functionNameJP":"バックエンドプログラム終了","functionNameEN":"close","parametersName":[],"parametersDataType":[],"returnValue":"void","functionId":"01HM2WJ7WYS82N34N3J3ZTH8E7","beforeCode":"\n\n\n","innerCode":"\n  if(parserStream){\n    // ストリームを中断・破棄\n    parserStream.pause();\n    parserStream.resume();\n    parserStream.destroy();\n    parserStream = null;\n  }\n  if(stmt){\n    progressMessage = `【処理中】データベースに送信した命令の完了を待っています。`;\n    await stmt.finalize();\n    stmt = null;\n  }\n  await close();   // 下層の関数を呼び出す\n  errorCount = 0;\n  allCount = 0;\n  successCount = 0;\n  csvSize = 0;\n  progressMessage = \"何も処理をしていません\";\n","afterCode":""}]