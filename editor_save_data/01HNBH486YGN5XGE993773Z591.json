[{"functionId":"test","functionNameJP":"テストコード","functionNameEN":"test","beforeCode":"","innerCode":"\n    await startUp(\"http://localhost:3000/\", true);\n    await getDebugMode();\n    await startTransaction();\n    await endTransaction();\n    await close();\n    //\n    //\n    await startUp(\"http://localhost:3000/\", true);\n    //\n    // CSVファイルに書き込むデータ\n    const data = [\n        ['John Doe', 25, 'New York'],\n        ['Jane Smith', 30, 'San Francisco'],\n        ['Bob Johnson', 22, 'Los Angeles']\n    ];\n    const csvText = data.map(row => row.join(',')).join('\\n');\n    //\n    // CSVファイルのパス\n    const cachePath = await getPath(\"CACHE\");\n    const csvFilePath = path.join(cachePath, 'test.csv');\n    //\n    // CSVファイルを作成してデータを書き込む\n    await fs.promises.writeFile(csvFilePath, csvText, 'utf8');\n    //\n    // CSVファイルからデータベースに読み込む\n    await createRecordsFromCsv(csvFilePath);\n    //\n    // テーブルから読み出す\n    const matrix = await runSqlReadOnly(`SELECT * FROM csv_data;`,{});\n    if (matrix.length !== data.length) {\n        console.log(matrix);\n        throw `インポートしたはずの件数と合致しません`;\n    }\n    if (matrix[0][\"c0\"] !== data[0][0]) {\n        console.log(matrix);\n        throw `インポートしたはずの内容と合致しません`;\n    }\n    //\n    // CSVファイルを削除\n    await fs.promises.rm(csvFilePath);\n    //\n    // テスト用のテーブルを削除\n    await runSqlWriteOnly(`\n        DROP TABLE IF EXISTS csv_data;\n    `,{});\n    //\n    // わざと再接続\n    await startUp(\"localhost:3000\", true);\n    //\n    await close();\n","afterCode":"","parametersName":[],"parametersDataType":[],"returnValue":"void"},{"functionNameJP":"CSVファイルインポート","functionNameEN":"createRecordsFromCsv","parametersName":["filePath"],"parametersDataType":["string"],"returnValue":"void","functionId":"01HM2VKCWJ5W6V3FFAGP4VTJZN","beforeCode":"\n\n\nimport iconv from 'iconv-lite';\nimport readline from 'readline';\nimport fs from 'fs';\n\n// 使用したnpmパッケージ「sqlite」\n//  https://github.com/kriasoft/node-sqlite#readme\n\n\n//【グローバル変数】CSVファイルを読み込む進捗\nlet errorCount = 0;\nlet allCount = 0;\nlet csvSize = 0;\nlet progressMessage = \"何も処理をしていません\";\nlet parserStream;\n\n\n\n\n","innerCode":"\n  if (!fs.existsSync(filePath)) {\n    throw 'ファイルが見つかりません。';\n  }\n  const db = await getDB();\n  if(!db){\n    throw \"データベースオブジェクト(db)がNULLです。\";\n  }\n  errorCount = 0;\n  allCount = 0;\n  //\n  //==============================================================================\n  // CSVファイルの行数と列数を調べる\n  progressMessage = `【処理中】CSVファイルの行数と列数を調べています。`;\n  let readline1 = readline.createInterface({\n    input: fs.createReadStream(filePath),\n    crlfDelay: Infinity   // 改行が見つかるまで待機\n  });\n  csvSize = 0;      // 行のサイズ\n  let columnSize = 0;   // 列のサイズ\n  let isFirstLine = true; \n  for await (const line of readline1) {\n    if(line.trim() === \"\") continue; // 空白をトリムしてから比較\n    if(isFirstLine){\n      columnSize = Object.keys(line.split(\",\")).length;\n      isFirstLine = false;\n    }\n    csvSize++;\n  }\n  if(csvSize===0){\n    throw \"CSVがゼロ行です。\";\n  }\n  if (columnSize === 0) {\n    throw `CSVファイルを読み込もうとしましたが、列が存在しません。`;\n  }\n  readline1.close();\n  readline1 = null;       // メモリを開放する\n  //\n  //==============================================================================\n  // テーブルを作り直す\n  progressMessage = `【処理中】トランザクション処理を開始しています。`;\n  await startTransaction();  // 開始\n  progressMessage = `【処理中】表「csv_data」を作り直しています。`;\n  await db.run(`DROP TABLE IF EXISTS csv_data;`);\n  const columnNames = [];\n  for (let i = 0; i < columnSize; i++) {\n    columnNames.push(`\"c${i}\"`);\n  }\n  await db.run(`CREATE TABLE IF NOT EXISTS csv_data( ${columnNames.join(\", \")} );`);\n  //\n  //\n  //==============================================================================\n  // データ移行の準備を行う\n  progressMessage = `【処理中】ファイルストリームを準備しています。`;\n  parserStream = fs.createReadStream(filePath)\n    .pipe(iconv.decodeStream('Shift_JIS'));\n  const readline2 = readline.createInterface({\n    input: parserStream,\n    crlfDelay: Infinity   // 改行が見つかるまで待機\n  });\n  progressMessage = `【処理中】SQLの命令文を準備しています。`;\n  const sql = `INSERT INTO csv_data VALUES ( ${new Array(columnSize).fill(\"?\").join(\", \")} )`;\n  let stmt = await db.prepare(sql);\n  //\n  //==============================================================================\n  // CSVファイルからデータベースへ移行する\n  progressMessage = `【処理中】データベースに命令しています。`;\n  let interval = 100;   // 100から10000まで増やす\n  for await (const line of readline2) {\n    if(!parserStream) {\n      throw new Error(\"処理が中断されました\");\n    }\n    let cells = [];\n    try {\n      cells = parseCsvLine(line);\n      // データベースに挿入する処理\n      await stmt.run(cells);\n    }\n    catch (err) {\n      if( cells.length !== columnSize ){\n        console.error(`\\n本来の列のサイズと異なります。\\n現状: ${cells.length}\\n本来: ${columnSize}`);\n        console.error(cells);\n      }\n      else{\n        console.error(`\\nCSVを解析中にエラー発生`);\n        console.error(line);\n      }\n    }\n    allCount++;\n    if (allCount % interval === 0) {\n      if(interval<=500){\n        interval += 100;\n      }\n      progressMessage = `【処理中】現時点までにデータベースに送った命令が、全て実行されるのを待っています。`;\n      await stmt.finalize();\n      // トランザクション処理で処理を高速化する。\n      //   開始と終了は、先頭と末尾に記述してあるので、\n      //   ここでは１万行ごとの再接続のみを行う。\n      progressMessage = `【処理中】トランザクション処理を終了しています。のちに再開する予定です。`;\n      await endTransaction();    // 終了\n      progressMessage = `【処理中】トランザクション処理を開始しています。`;\n      await startTransaction();  // 開始\n      progressMessage = `【処理中】SQLの命令文を準備しています。`;\n      stmt = await db.prepare(sql);\n      progressMessage = `【処理中】データベースに命令しています。`;\n    }\n  }\n  //==============================================================================\n  progressMessage = `【処理中】命令が全て実行されるのを待っています。`;\n  await stmt.finalize();\n  progressMessage = `【処理中】ファイルストリームを破棄しています。`;\n  parserStream.destroy();\n  parserStream = null;\n  progressMessage = `【処理中】トランザクション処理を終了しています。`;\n  await endTransaction();    // 終了\n  progressMessage = `完了しました。`;\n","afterCode":""},{"functionNameJP":"インポートの進捗状況を取得する関数","functionNameEN":"getCsvProgress","parametersName":[],"parametersDataType":[],"returnValue":{"progressMessage":"string","successCount":"number","errorCount":"number","csvSize":"number"},"functionId":"01HM2VW7578HFQ3HKS086Y037K","beforeCode":"\n\n\n\n// CSV行を配列へ変換する関数\n//  参考：https://zenn.dev/itte/articles/516228940932a5\nconst parseCsvLine = line => line.split(',').reduce(([data, isInQuotes], text) => {\n  if (isInQuotes) {\n    data[data.length - 1] += ',' + text.replace(/\\\"+/g, m => '\"'.repeat(m.length / 2))\n    return [data, !(text.match(/\\\"*$/)[0].length % 2)]\n  } else {\n    const match = text.match(/^(\\\"?)((.*?)(\\\"*))$/)\n    data.push(match[1] ? match[2].replace(/\\\"+/g, m => '\"'.repeat(m.length / 2)) : match[2])\n    return [data, match[1] && !(match[4].length % 2)]\n  }\n}, [[]])[0]\n\n\n","innerCode":"\n  return {\n    \"progressMessage\": progressMessage,\n    \"successCount\": allCount - errorCount,\n    \"errorCount\": errorCount,\n    \"csvSize\": csvSize,\n  }\n","afterCode":""},{"functionNameJP":"インポートを中断する関数","functionNameEN":"destroyCSV","parametersName":[],"parametersDataType":[],"returnValue":"string","functionId":"01HN9C6Q664SGW914SWSDC9FF1","beforeCode":"\n\n\n","innerCode":"\n  setTimeout(()=>{\n    errorCount = 0;\n    allCount = 0;\n    csvSize = 0;\n    progressMessage = \"何も処理をしていません\";\n  },500);\n  if(parserStream){\n    // ストリームを中断・破棄\n    parserStream.pause();\n    parserStream.resume();\n    parserStream.destroy();\n    parserStream = null;\n    return \"CSVのアップロード処理を中断しました。\";\n  }\n  else{\n    return \"現在、何も実行されていません。\";\n  }\n","afterCode":""},{"functionNameJP":"バックエンドプログラム終了","functionNameEN":"close","parametersName":[],"parametersDataType":[],"returnValue":"void","functionId":"01HM2WJ7WYS82N34N3J3ZTH8E7","beforeCode":"\n\n\n","innerCode":"\n  errorCount = 0;\n  allCount = 0;\n  csvSize = 0;\n  progressMessage = \"何も処理をしていません\";\n  if(parserStream){\n    // ストリームを中断・破棄\n    parserStream.pause();\n    parserStream.resume();\n    parserStream.destroy();\n    parserStream = null;\n  }\n  await close();   // 下層の関数を呼び出す\n","afterCode":""}]